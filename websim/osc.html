<!DOCTYPE html>
<html>
<!-- TODO: make sure headroom is the same as the hardware -->

<head>
  <meta charset="utf-8">
  <title>logue-sdk osc</title>
  <script src="scripts/qwerty-hancock.js"></script>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Space Grotesk', sans-serif;
      -webkit-font-smoothing: subpixel-antialiased;
    }
  </style>
</head>

<body>
  <!-- add buttons and sliders here -->
  <button id="TogglePlaybackButton">Toggle playback</button>
  <h2>Master Volume</h2>
  <input type="range" min=0 max=1 value=0.5 step=0.01 id="VolumeSlider">
  <span id="VolumeLabel"></span>

  <!-- <h2>BPM</h2>
  <input type="range" min=30 max=240 value=120 step=0.1 id="BpmSlider">
  <span id="BpmLabel"></span> -->

  <h2>Oscillator</h2>
  <p>Tips: play with a QWERTY keyboard, Z and X to switch octave </p>
  <!-- <select id="OscillatorType">
    <option value="sawtooth">Sawtooth</option>
    <option value="square">Square</option>
    <option value="triangle">Triangle</option>
    <option value="sine">Sine</option>
    <option value="noise">Noise</option>
  </select> -->
  <button id="OscLatchButton">Latch Off</button>
  <div id="keyboard"></div>

  <h2>Scope</h2>
  <canvas id="TimeDomain" width="512" height="128"></canvas><br />
  <canvas id="FrequencyDomain" width="512" height="128"></canvas>

  <h2>Parameters</h2>
  <div id="Parameters"></div>

  <script>
    // Expose function globally so EM_ASM can call it
    window.setupWebAudioAndUI = function (context, wasmProcessor) {

      const AHREnvelopeTime = 0.1;

      function approximatelyEqual(a, b, epsilon = 1e-4) {
        return Math.abs(a - b) < epsilon;
      }

      function createSlider(wasmProcessor, param, index) {
        let container = document.createElement("div");

        let label = document.createElement("label");
        label.textContent = param.name.toLowerCase();
        label.style.display = "inline-block";
        label.style.width = "100px";
        label.style.marginRight = "10px";
        container.appendChild(label);

        let input = document.createElement("input");
        input.type = "range";
        input.min = param.min;
        input.max = param.max;
        input.step = 1;
        input.value = param.init;
        input.id = param.name;
        input.style.width = "200px";
        input.style.marginRight = "10px";
        container.appendChild(input);

        let value_string = document.createElement("span");
        value_string.textContent = Module.getParameterValueString(index, input.value);
        container.appendChild(value_string);

        // Emscripten's API creates these from a C array, indexing them instead of a
        // name. Chrome and FF work with 0 but Safari requires the correct "0".
        let audio_parameter = wasmProcessor.parameters.get(`${index}`);

        input.oninput = () => {
          value_string.textContent = Module.getParameterValueString(index, input.value);
          audio_parameter.value = input.value;
        };

        document.getElementById("Parameters").appendChild(container);
      }

      // audio graph
      // let oscillator = new OscillatorNode(context, { frequency: 440.0 });
      let envelope = new GainNode(context, { gain: 0.0 });
      let volume = new GainNode(context, { gain: 0.1 })
      let analyser = new AnalyserNode(context, { fftSize: 4096 });
      let data = new Float32Array(analyser.frequencyBinCount);

      // let noise = new AudioBufferSourceNode(context, { loop: true });
      // noise.buffer = context.createBuffer(1, context.sampleRate, context.sampleRate);
      // for (i = 0; i < context.sampleRate; i++) {
      //   noise.buffer.getChannelData(0)[i] = 2 * Math.random() - 1;
      // }

      wasmProcessor.connect(envelope).connect(volume).connect(context.destination);
      envelope.connect(analyser);

      // let samplesDiv = document.getElementById("Samples");
      // let audioElements = samplesDiv.getElementsByTagName("audio");
      // for (let audio of audioElements) {
      //   let source = context.createMediaElementSource(audio);
      //   source.connect(wasmProcessor);
      // }

      // resume/stop button
      let togglePlaybackButton = document.getElementById("TogglePlaybackButton");
      togglePlaybackButton.onclick = () => {
        if (context.state !== "running") {
          context.resume();
        } else {
          context.suspend();
        }
      };

      // main volume
      let volumeSlider = document.getElementById("VolumeSlider");
      let volumeLabel = document.getElementById("VolumeLabel");
      volume.gain.value = volumeSlider.value; // expontial ramp do not work here, need proper smoothing
      volumeLabel.innerText = volumeSlider.value;
      volumeSlider.oninput = function () {
        volume.gain.value = this.value;
        volumeLabel.innerText = this.value;
      };

      // BPM
      // let bpmSlider = document.getElementById("BpmSlider");
      // let bpmLabel = document.getElementById("BpmLabel");
      // bpmLabel.innerText = bpmSlider.value;

      // bpmSlider.oninput = function () {
      //   bpmLabel.innerText = this.value;
      //   Module.fx_set_bpm(this.value);
      // };

      // keyboard osc
      let currentOctave = 3;
      let keyboard = new QwertyHancock({
        id: "keyboard",
        width: 512,
        height: 64,
        octaves: currentOctave,
        startNote: "A2",
        whiteNotesColour: "white",
        blackNotesColour: "black",
        hoverColour: "#f3e939"
      });

      let osc_frequency = 440.0;

      let latchEnabled = false;
      let latchButton = document.getElementById("OscLatchButton");
      latchButton.onclick = function () {
        latchEnabled = !latchEnabled;
        this.innerText = `Latch ${latchEnabled ? "On" : "Off"}`;

        if (!latchEnabled) {
          if (window.frequencyStack.length === 0) {
            envelope.gain.cancelAndHoldAtTime(context.currentTime);
            envelope.gain.linearRampToValueAtTime(0.0, context.currentTime + AHREnvelopeTime);
          }
        }
      };

      keyboard.keyDown = function (note, frequency) {
        if (!window.frequencyStack) {
          window.frequencyStack = [];
        }
        window.frequencyStack.push(frequency);
        osc_frequency = frequency;
        Module.setOscPitch(osc_frequency);
        envelope.gain.cancelAndHoldAtTime(context.currentTime);
        envelope.gain.linearRampToValueAtTime(1.0, context.currentTime + AHREnvelopeTime);
      };

      keyboard.keyUp = function (note, frequency) {
        // Remove the frequency from the stack (last matching entry)
        for (let i = window.frequencyStack.length - 1; i >= 0; --i) {
          if (approximatelyEqual(window.frequencyStack[i], frequency)) {
            window.frequencyStack.splice(i, 1);
            break;
          }
        }

        // latest note priority
        if (window.frequencyStack.length > 0) {
          osc_frequency = window.frequencyStack[window.frequencyStack.length - 1];
          Module.setOscPitch(osc_frequency);
        }
        else {
          if (!latchEnabled) {
            envelope.gain.cancelAndHoldAtTime(context.currentTime);
            envelope.gain.linearRampToValueAtTime(0.0, context.currentTime + AHREnvelopeTime);
          }
        }
      };

      document.addEventListener("keydown", (e) => {
        if (e.key === "z") {
          currentOctave = Math.max(0, currentOctave - 1);
          keyboard.setKeyOctave(currentOctave);
        } else if (e.key === "x") {
          currentOctave = Math.min(7, currentOctave + 1);
          keyboard.setKeyOctave(currentOctave);
        }
      });

      // scope
      let canvasWave = document.getElementById("TimeDomain");
      let canvasFFT = document.getElementById("FrequencyDomain");
      let canvasWaveContext = canvasWave.getContext("2d");
      let canvasFFTContext = canvasFFT.getContext("2d");
      draw();
      function draw() {
        analyser.getFloatTimeDomainData(data);

        canvasWaveContext.fillStyle = "rgb(255, 255, 255)";
        canvasWaveContext.fillRect(0, 0, canvasWave.width, canvasWave.height);
        canvasWaveContext.lineWidth = 1;
        canvasWaveContext.strokeStyle = "rgb(0, 0, 0)";
        canvasWaveContext.beginPath();

        // find trigger point
        let start_index = 0;
        let score_max = 0.0;

        let dx = Math.floor(400 / osc_frequency) + 1;

        for (let i = dx; i < data.length / 2; ++i) {
          if ((data[i - 1] > 0) && (data[i + 1] < 0)) { // zero-cross point
            let score = (data[i - dx] - data[i + dx]) - data[i + 5 * dx];
            if (score > score_max) {
              score_max = score;
              start_index = i;
            }
          }
        }

        let num_of_half_cycles = Math.floor(analyser.fftSize * osc_frequency / context.sampleRate) - 1;
        let end_index = data.length - 1;
        if (num_of_half_cycles > 0) {
          end_index = Math.round(start_index + num_of_half_cycles * context.sampleRate / osc_frequency / 2);
        }

        let delta_x = canvasWave.width / (end_index - start_index);
        let x = 0;

        for (let i = start_index; i <= end_index; i++) {
          let v = data[i];
          let y = (v * 0.5 + 1.0) * canvasWave.height / 2; // -2..2 range

          if (i === start_index) {
            canvasWaveContext.moveTo(x, y);
          } else {
            canvasWaveContext.lineTo(x, y);
          }

          x += delta_x;
        }
        canvasWaveContext.stroke();

        analyser.getFloatFrequencyData(data);

        canvasFFTContext.clearRect(0, 0, canvasFFT.width, canvasFFT.height);

        let deltaX = canvasFFT.width / data.length;
        let posX = 0;
        for (let i = 0; i < data.length; i++) {
          let barHeight = data[i] + canvasFFT.height;
          canvasFFTContext.fillStyle = "rgb(0, 0, 0)";
          canvasFFTContext.fillRect(
            posX,
            canvasFFT.height - barHeight,
            deltaX,
            barHeight,
          );
          posX += deltaX;
        }
        requestAnimationFrame(draw);
      }

      // audio processor parameters
      let parameters = Module.getValidParameters();
      for (let i = 0; i < parameters.size(); ++i) {
        let param = parameters.get(i);
        createSlider(wasmProcessor, param, i);
      }
    };
  </script>

  {{{ SCRIPT }}}
</body>

</html>