#pragma once

#include <atomic>

#include "unit_osc.h"
#include "runtime.h"
#include "utils/buffer_ops.h"
#include "utils/mk2_utils.h"
#include "utils/float_simd.h"
#include "utils/io_ops.h"
#include "utils/fixed_math.h"
#include "dsp/mk2_biquad.hpp"
#include <string>
#include <unistd.h>

#ifndef fast_inline
#define fast_inline __attribute__((optimize("Ofast"), always_inline)) inline
#endif

class Vox
{
public: 
  /*===========================================================================*/
  /* Public Data Structures/Types. */
  /*===========================================================================*/

  /*===========================================================================*/
  /* Lifecycle Methods. */
  /*===========================================================================*/

  Vox(void) : 
  mPitchModDepthCurve
  {
    0.f,  

    // 0 ~ 1 18 steps
    0.009994507f, 0.019989014f, 0.029998779f, 0.039993286f,
    0.049987793f, 0.099990845f, 0.125f,       0.149993896f,
    0.199996948f, 0.25f,        0.375f,       0.5f,
    0.6f,         0.65f,        0.75f,        0.8f,
    0.875f,       0.95f,

    // 0.25 semi resolution 20 steps
    1.f,  1.25f, 1.5f, 1.75f,
    2.f,  2.25f, 2.5f, 2.75f,
    3.f,  3.25f, 3.5f, 3.75f,
    4.f,  4.25f, 4.5f, 4.75f,
    5.f,  5.25f, 5.5f, 5.75f,

    // 0.5 semi resolution 12 steps
    6.f,  6.5f,  7.f,  7.5f,
    8.f,  8.5f,  9.f,  9.5f,
    10.f, 10.5f, 11.f, 11.5f,

    // 1 semi resolution 13 steps
    12.f, 13.f, 14.f, 15.f, 
    16.f, 17.f, 18.f, 19.f,
    20.f, 21.f, 22.f, 23.f, 
    24.f, 24.f
  },
  mCutoffs
  { 
    {800, 300, 300, 500, 500}, 
    {1200, 2300, 1200, 1900, 800}, 
    {2500, 2900, 2500, 2500, 2500} 
  }
  {}
  
  ~Vox(void) 
  {}

  inline int8_t Init(const unit_runtime_desc_t * desc) 
  {
    // Note: make sure the unit is being loaded to the correct platform/module target
    if (desc->target != unit_header.target)
      return k_unit_err_target;
      
    // Note: check API compatibility with the one this unit was built against
    if (!UNIT_API_IS_COMPAT(desc->api))
      return k_unit_err_api_version;
  
    // Check compatibility of samplerate with unit, for microkorg2 should be 48000
    if (desc->samplerate != 48000)
      return k_unit_err_samplerate;

    // Check compatibility of frame geometry
    // if (desc->output_channels != 2)  // should be stereo output
    //   return k_unit_err_geometry;

    // Cache runtime descriptor to keep access to API hooks
    runtime_desc_ = *desc;

    buf_clr_i32(mPhase, kMk2MaxVoices);
    buf_clr_i32(mPhaseInc, kMk2MaxVoices);

    for(int i = 0; i < kNumParams; i++)
    {
      mParameter[i] = unit_header.params[i].init;
    }

    return k_unit_err_none;
  }

  inline void Teardown() 
  {
    // Note: cleanup and release resources if any
  }

  inline void Reset() 
  {
    buf_clr_i32(mPhase, kMk2MaxVoices);
    buf_clr_f32(mFormantMod, kMk2MaxVoices);
    buf_clr_f32(mResoMod, kMk2MaxVoices);
    buf_clr_f32(mShapeMod, kMk2MaxVoices);
    buf_clr_f32(mPitchMod, kMk2MaxVoices);
    buf_clr_f32(mNoiseLevelMod, kMk2MaxVoices);
    buf_clr_f32(mSawZ, kMk2MaxVoices);
    buf_clr_f32(mOscBuffer, kMk2HalfVoices * kMk2BufferSize);
    
    // jump smoothing to target value
    buf_cpy_f32(mShape, mShapeZ, kMk2MaxVoices);
    buf_cpy_f32(mNoiseLevel, mNoiseLevelZ, kMk2MaxVoices);
    buf_cpy_f32(mWaveLevel, mWaveLevelZ, kMk2MaxVoices);

    mFormantFilter1.flush();
    mFormantFilter2.flush();
    mFormantFilter3.flush();

    // set starting seeds 
    // (generated by arbitrarily advancing seed suggested in comments of https://www.musicdsp.org/en/latest/Synthesis/216-fast-whitenoise-generator.html)
    mNoiseX1[0] = 0x70f4f854;
    mNoiseX2[0] = 0xe1e9f0a7;
    mNoiseX1[1] = 0x04a4185f;
    mNoiseX2[1] = 0xbc4bf7f9;
    mNoiseX1[2] = 0x89356c76;
    mNoiseX2[2] = 0x89ee0aff;
    mNoiseX1[3] = 0xfb36f7f0;
    mNoiseX2[3] = 0x54937dd5;
    mNoiseX1[4] = 0xa1e6b215;
    mNoiseX2[4] = 0x371ca5e5;
    mNoiseX1[5] = 0x17f03725;
    mNoiseX2[5] = 0xa77678fa;
    mNoiseX1[6] = 0x0550edf3;
    mNoiseX2[6] = 0x6fc3b23d;
    mNoiseX1[7] = 0xe9022ddf;
    mNoiseX2[7] = 0xfbde61d9;
  }

  inline void Resume() 
  {
    // Note: Synth will resume and exit suspend state. Usually means the synth
    // was selected and the render callback will be called again
    Reset();
  }

  inline void Suspend() 
  {
    // Note: Synth will enter suspend state. Usually means another synth was
    // selected and thus the render callback will not be called
  }

  /*===========================================================================*/
  /* Other Public Methods. */
  /*===========================================================================*/

  fast_inline void Process(float * out, size_t frames) 
  {
    const unit_runtime_osc_context_t * ctxt = static_cast<const unit_runtime_osc_context_t *>(runtime_desc_.hooks.runtime_context);
    UpdateVoicePitch(ctxt->pitch, ctxt->voiceLimit);
    CalculateFilterCoeffs(ctxt);
    UpdateShape(ctxt->voiceLimit);
    UpdateNoiseLevel(ctxt->voiceLimit);

    switch (ctxt->voiceLimit)
    {
      case kMk2MaxVoices:
      {
        ProcessOscx4(ctxt, 0, out, frames);
        ProcessOscx4(ctxt, 4, out, frames);
        break;
      }
    
      case kMk2HalfVoices:
      {
        ProcessOscx4(ctxt, 0, out, frames);
        break;
      }

      case kMk2QuarterVoices:
      {
        ProcessOscx2(ctxt, 0, out, frames);
        break;
      }

      case kMk2SingleVoice:
      {
        ProcessOscx1(ctxt, 0, out, frames);
        break;
      }
      default:
        break;
    }
  }

  inline void setParameter(uint8_t index, int32_t value) 
  {
    if (index >= kNumParams) return;

    mParameter[index] = value;
    switch (index)
    {
      default:
        break;
    }
  }

  inline int32_t getParameterValue(uint8_t index) const 
  {
    if (index >= kNumParams) return 0;
    return mParameter[index];
  }

  inline const char * getParameterStrValue(uint8_t index, int32_t value) const 
  {
    switch (index) 
    {
      case kParamSyllable:
      {
        char vowels[] = { 'A', 'I', 'U', 'E', 'O' };

        int leftIdx = value / 100;
        int rightIdx = (leftIdx == 4) ? 4 : leftIdx + 1;
        char left = vowels[leftIdx];
        char right = vowels[rightIdx];
        int displayNum = value - leftIdx * 100;
        std::string ret = "}" + std::to_string(displayNum);
        ret = ret + "{" + left + ' ' + ':' + ' ' + right;
        return ret.c_str();
        break;
      }

      default:
        break;
    }

    return nullptr;
  }

  /*===========================================================================*/
  /* Static Members. */
  /*===========================================================================*/

  void UpdateVoicePitch(const float * noteNumber, uint8_t numVoices)
  {
    const float frequencyMultiplier = 0x7FFFFFFF;

    const float transpose = mParameter[kParamSemi] + mParameter[kParamFine] * 0.01;
    switch (numVoices)
    {
      case kMk2MaxVoices:
      case kMk2HalfVoices:
      {
        for(int i = 0; i < numVoices; i+=4)
        {
          float32x4_t note = f32x4_dup(transpose);
          note = float32x4_add(note, float32x4_add(f32x4_ld(&noteNumber[i]), f32x4_ld(&mPitchMod[i])));
          uint32x4_t noteWhole = si_f32x4_to_u32x4(note);
          float32x4_t frequency = osc_w0f_for_notex4(noteWhole, float32x4_sub(note, si_u32x4_to_f32x4(noteWhole)));
          s32x4_str(&mPhaseInc[i], int32x4_mulscal(si_f32x4_to_i32x4(float32x4_mulscal(frequency, frequencyMultiplier)), 2));
          f32x4_str(&mDpwGainCompensation[i], vrecpeq_f32(float32x4_mulscal(frequency, 8.f)));
        }
        break;
      }

      case kMk2QuarterVoices:
      {
        float32x2_t note = f32x2_dup(transpose);
        note = float32x2_add(note, float32x2_add(f32x2_ld(&noteNumber[0]), f32x2_ld(&mPitchMod[0])));
        uint32x2_t noteWhole = si_f32x2_to_u32x2(note);
        float32x2_t frequency = osc_w0f_for_notex2(noteWhole, float32x2_sub(note, si_u32x2_to_f32x2(noteWhole)));
        s32x2_str(&mPhaseInc[0], int32x2_mulscal(si_f32x2_to_i32x2(float32x2_mulscal(frequency, frequencyMultiplier)), 2));
        f32x2_str(&mDpwGainCompensation[0], vrecpe_f32(float32x2_mulscal(frequency, 8.f)));
      break;
      }

      case kMk2SingleVoice:
      {
        float note = transpose + noteNumber[0] + mPitchMod[0];
        uint8_t noteWhole = static_cast<uint8_t>(note);
        float frac = noteNumber[0] - static_cast<float>(noteWhole);
        float frequency = osc_w0f_for_note(noteWhole, static_cast<uint8_t>(frac * 0xFF));
        mPhaseInc[0] = static_cast<int32_t>(frequency * frequencyMultiplier) * 2;  
        mDpwGainCompensation[0] = 1.f/(8.f * frequency);
        break;
      }
      default:
        break;
    }
  }

  void UpdateShape(uint8_t numVoices)
  {
    float shape = mParameter[kParamShape] * 0.01;
    for(int i = 0; i < numVoices; i+=4)
    {
      float32x4_t shapePlusMod = float32x4_add(f32x4_dup(shape), f32x4_ld(&mShapeMod[i]));
      f32x4_str(&mShape[i], clipminmaxfx4(f32x4_dup(0.f), shapePlusMod, f32x4_dup(1.f)));
    }
  }

  void UpdateNoiseLevel(uint8_t numVoices)
  {
    const float mix = mParameter[kParamNoise] * 0.01;
    for(int i = 0; i < numVoices; i+=4)
    {
      float32x4_t mixWithMod = float32x4_add(f32x4_dup(mix), f32x4_ld(&mNoiseLevelMod[i]));
      f32x4_str(&mNoiseLevel[i], clipminmaxfx4(f32x4_dup(0.f), mixWithMod, f32x4_dup(1.f)));
      f32x4_str(&mWaveLevel[i], clipminmaxfx4(f32x4_dup(0.f), float32x4_sub(f32x4_dup(1.f), mixWithMod), f32x4_dup(1.f)));
    }
  }

  void unit_platform_exclusive(uint8_t messageId, void * data, uint32_t /*dataSize*/) 
  {
    const unit_runtime_osc_context_t * ctxt = static_cast<const unit_runtime_osc_context_t *>(runtime_desc_.hooks.runtime_context);
    switch (messageId)
    {
      case kMk2PlatformExclusiveModData:
      {
        float * modDepth = GetModDepth(data);
        float * modData = GetModData(data);

        // copy data to work buffers
        buf_cpy_f32(&modData[ctxt->voiceLimit * kModDestSyllable], mSyllableMod, ctxt->voiceLimit);
        buf_cpy_f32(&modData[ctxt->voiceLimit * kModDestFormant], mFormantMod, ctxt->voiceLimit);
        buf_cpy_f32(&modData[ctxt->voiceLimit * kModDestResonance], mResoMod, ctxt->voiceLimit);
        buf_cpy_f32(&modData[ctxt->voiceLimit * kModDestShape], mShapeMod, ctxt->voiceLimit);
        buf_cpy_f32(&modData[ctxt->voiceLimit * kModDestPitch], mPitchMod, ctxt->voiceLimit);
        buf_cpy_f32(&modData[ctxt->voiceLimit * kModDestNoise], mNoiseLevelMod, ctxt->voiceLimit);

        // apply depth (just calculate all 8 voices for simplicity, even though not every voice is necessarily being used)
        int numVoices = kMk2MaxVoices;

        // pitch mod range is very wide, so apply curve to make this parameter more useful
        const float range = float(PitchModDepthCurveTableSize - 1);
        const float pitchModDepthParam = si_fabsf(modDepth[kModDestPitch]) * range;
        const uint32_t pitchModDepthIndex = static_cast<uint32_t>(pitchModDepthParam);
        const float pitchModDepth = linintf(pitchModDepthParam - pitchModDepthIndex, 
                                            mPitchModDepthCurve[pitchModDepthIndex], 
                                            mPitchModDepthCurve[pitchModDepthIndex + 1]);

        for(int i = 0; i < numVoices; i+=4)
        {
          f32x4_str(&mSyllableMod[i], float32x4_mulscal(f32x4_ld(&mSyllableMod[i]), modDepth[kModDestSyllable]));
          f32x4_str(&mFormantMod[i], float32x4_mulscal(f32x4_ld(&mFormantMod[i]), modDepth[kModDestFormant]));
          f32x4_str(&mResoMod[i], float32x4_mulscal(f32x4_ld(&mResoMod[i]), modDepth[kModDestResonance]));
          f32x4_str(&mShapeMod[i], float32x4_mulscal(f32x4_ld(&mShapeMod[i]), modDepth[kModDestShape]));
          f32x4_str(&mPitchMod[i], float32x4_mulscal(f32x4_ld(&mPitchMod[i]), pitchModDepth));          
          f32x4_str(&mNoiseLevelMod[i], float32x4_mulscal(f32x4_ld(&mNoiseLevelMod[i]), modDepth[kModDestNoise]));          
        }
        break;
      }
    
      case kMk2PlatformExclusiveModDestName:
      {
        char * modName = GetModDestNameData(data);
        uint8_t modIndex = modName[0];
        switch (modIndex)
        {
          case kModDestSyllable:
          {
            modName[1] = 'S';
            modName[2] = 'y';
            modName[3] = 'l';
            modName[4] = 'l';
            modName[5] = 'a';
            modName[6] = 'b';
            modName[7] = 'l';
            modName[8] = 'e';
            break;
          }

          case kModDestFormant:
          {
            modName[1] = 'F';
            modName[2] = 'o';
            modName[3] = 'r';
            modName[4] = 'm';
            modName[5] = 'a';
            modName[6] = 'n';
            modName[7] = 't';
            break;
          }

          case kModDestResonance:
          {
            modName[1] = 'R';
            modName[2] = 'e';
            modName[3] = 's';
            modName[4] = 'o';
            break;
          }

          case kModDestShape:
          {
            modName[1] = 'S';
            modName[2] = 'h';
            modName[3] = 'a';
            modName[4] = 'p';
            modName[5] = 'e';
            break;
          }

          case kModDestPitch:
          {
            modName[1] = 'P';
            modName[2] = 'i';
            modName[3] = 't';
            modName[4] = 'c';
            modName[5] = 'h';
            break;
          }

          case kModDestNoise:
          {
            modName[1] = 'N';
            modName[2] = 'o';
            modName[3] = 'i';
            modName[4] = 's';
            modName[5] = 'e';
            break;
          }
          default:
            break;
        }
        break;
      }
      default:
        break;  
    }
  }

 private:
  /*===========================================================================*/
  /* Private Classes. */
  /*===========================================================================*/

  /*===========================================================================*/
  /* Private Member Variables. */
  /*===========================================================================*/

  enum
  {
    kParamSyllable,
    kParamFormant,
    kParamResonance,
    kParamShape,
    kParamSemi,
    kParamFine,
    kParamNoise,
    kNumParams
  };

  enum
  {
    kModDestSyllable,
    kModDestFormant,
    kModDestResonance,
    kModDestShape,
    kModDestPitch,
    kModDestNoise,
    kNumModDest
  };

  unit_runtime_desc_t runtime_desc_;
  int32_t mPhase[kMk2MaxVoices];
  int32_t mPhaseInc[kMk2MaxVoices];
  int32_t mNoiseX1[kMk2MaxVoices];
  int32_t mNoiseX2[kMk2MaxVoices];
  float mSawZ[kMk2MaxVoices];
  float mOscBuffer[kMk2HalfVoices * kMk2BufferSize]; // max voices to process at one time is 4

  // param
  float mDpwGainCompensation[kMk2MaxVoices];
  float mShape[kMk2MaxVoices];
  float mShapeZ[kMk2MaxVoices];
  float mNoiseLevel[kMk2MaxVoices];
  float mNoiseLevelZ[kMk2MaxVoices];
  float mWaveLevel[kMk2MaxVoices];
  float mWaveLevelZ[kMk2MaxVoices];

  // mod
  float mSyllableMod[kMk2MaxVoices];
  float mFormantMod[kMk2MaxVoices];
  float mResoMod[kMk2MaxVoices];
  float mShapeMod[kMk2MaxVoices];
  float mPitchMod[kMk2MaxVoices];
  float mNoiseLevelMod[kMk2MaxVoices];

  enum { PitchModDepthCurveTableSize = 65 };
  const float mPitchModDepthCurve[PitchModDepthCurveTableSize];
  const float mCutoffs[3][5];

  dsp::ParallelBiQuad<kMk2MaxVoices>::ParallelCoeffs mFormantCoeffs[3];
  dsp::ParallelBiQuad<kMk2MaxVoices> mFormantFilter1;
  dsp::ParallelBiQuad<kMk2MaxVoices> mFormantFilter2;
  dsp::ParallelBiQuad<kMk2MaxVoices> mFormantFilter3;

  int32_t mParameter[kNumParams];

  std::atomic_uint_fast32_t flags_;

  /*===========================================================================*/
  /* Private Methods. */
  /*===========================================================================*/

  void CalculateFilterCoeffs(const unit_runtime_osc_context_t * ctxt)
  {
    dsp::BiQuad::Coeffs dummy;
    for(int i = 0; i < ctxt->voiceLimit; i++)
    {
      float reso = clipminmaxf(1.f, mParameter[kModDestResonance] * 0.1 + mResoMod[i] * 10.f, 10.f);
      float syllable = clipminmaxf(0.f, mParameter[kModDestSyllable] * 0.01 + mSyllableMod[i] * 4.f, 4.f);
      float shift = 1.f + clipminmaxf(-0.5f, mParameter[kModDestFormant] * 0.01 + mFormantMod[i], 0.5);

      int formantWhole = static_cast<int>(syllable);
      int formantWhole_1 = (formantWhole == 4) ? 4.f : formantWhole + 1;
      float formantFrac = syllable - formantWhole;
  
      float f1 = linintf(formantFrac, mCutoffs[0][formantWhole], mCutoffs[0][formantWhole_1]) * shift;
      float f2 = linintf(formantFrac, mCutoffs[1][formantWhole], mCutoffs[1][formantWhole_1]) * shift;
      float f3 = linintf(formantFrac, mCutoffs[2][formantWhole], mCutoffs[2][formantWhole_1]) * shift;
  
      float f1_k = dsp::BiQuad::Coeffs::tanPiWc(dsp::BiQuad::Coeffs::wc(f1, 1.f/runtime_desc_.samplerate));
      float f2_k = dsp::BiQuad::Coeffs::tanPiWc(dsp::BiQuad::Coeffs::wc(f2, 1.f/runtime_desc_.samplerate));
      float f3_k = dsp::BiQuad::Coeffs::tanPiWc(dsp::BiQuad::Coeffs::wc(f3, 1.f/runtime_desc_.samplerate));
      
      dummy.setSOBP(f1_k, reso);
      mFormantCoeffs[0].set_coeffs(dummy, i);

      dummy.setSOBP(f2_k, reso);
      mFormantCoeffs[1].set_coeffs(dummy, i);

      dummy.setSOBP(f3_k, reso);
      mFormantCoeffs[2].set_coeffs(dummy, i);
    }
  }

  void ProcessOscx4(const unit_runtime_osc_context_t * ctxt, int voiceNum, float * out, size_t frames)
  {
    GenerateWaveX4(voiceNum, frames);
    GenerateNoiseX4(voiceNum, frames);

    const int offset = GetBufferOffset(ctxt, voiceNum, frames);
    float32x4_t filterOut;
    for(uint32_t i = 0; i < frames; i++)
    {
      float32x4_t sample = get_interlaced_samplef32x4(mOscBuffer, i, 0, 4);
      filterOut = mFormantFilter1.process_so_x4(sample, mFormantCoeffs[0], voiceNum);
      filterOut = float32x4_add(filterOut, mFormantFilter2.process_so_x4(sample, mFormantCoeffs[1], voiceNum));
      filterOut = float32x4_add(filterOut, mFormantFilter3.process_so_x4(sample, mFormantCoeffs[2], voiceNum));
      write_oscillator_output_x4(out, filterOut, offset, ctxt->outputStride, i);
    }
    WriteUnitModDatax4(ctxt, filterOut, voiceNum);
  }

  void ProcessOscx2(const unit_runtime_osc_context_t * ctxt, int voiceNum, float * out, size_t frames)
  {
    GenerateWaveX2(voiceNum, frames);
    GenerateNoiseX2(voiceNum, frames);

    const int offset = GetBufferOffset(ctxt, voiceNum, frames);
    float32x2_t filterOut;
    for(uint32_t i = 0; i < frames; i++)
    {
      float32x2_t sample = get_interlaced_samplef32x2(mOscBuffer, i, 0, 2);
      filterOut = mFormantFilter1.process_so_x2(sample, mFormantCoeffs[0], voiceNum);
      filterOut = float32x2_add(filterOut, mFormantFilter2.process_so_x2(sample, mFormantCoeffs[1], voiceNum));
      filterOut = float32x2_add(filterOut, mFormantFilter3.process_so_x2(sample, mFormantCoeffs[2], voiceNum));
      write_oscillator_output_x2(out, filterOut, offset, ctxt->outputStride, i, ctxt->voiceOffset);
    }
    WriteUnitModDatax2(ctxt, filterOut, 0);
  }

  void ProcessOscx1(const unit_runtime_osc_context_t * ctxt, int voiceNum, float * out, size_t frames)
  {
    GenerateWaveX1(voiceNum, frames);
    GenerateNoiseX1(voiceNum, frames);

    const int offset = GetBufferOffset(ctxt, voiceNum, frames);
    float filterOut;
    for(uint32_t i = 0; i < frames; i++)
    {
      float sample = get_interlaced_sample(mOscBuffer, i, 0, 1);
      filterOut = mFormantFilter1.process_so_x1(sample, mFormantCoeffs[0], voiceNum);
      filterOut = filterOut + mFormantFilter2.process_so_x1(sample, mFormantCoeffs[1], voiceNum);
      filterOut = filterOut + mFormantFilter3.process_so_x1(sample, mFormantCoeffs[2], voiceNum);
      write_oscillator_output_x1(out, filterOut, offset, ctxt->outputStride, i, ctxt->voiceOffset);
    }
    WriteUnitModDatax1(ctxt, filterOut, 0);
  }

  // original DPW paper https://ieeexplore.ieee.org/abstract/document/5153306
  // extended https://www.researchgate.net/publication/224557976_Alias-Suppressed_Oscillators_Based_on_Differentiated_Polynomial_Waveforms
  void GenerateWaveX1(const uint32_t voiceNum, const uint32_t frames)
  {
    int32_t phase = mPhase[voiceNum];
    int32_t inc = mPhaseInc[voiceNum];
    float sawZ = mSawZ[voiceNum];
    
    const float invFrames = 1.f / float(frames);
    const float shapeDelta = (mShape[voiceNum] - mShapeZ[voiceNum]) * invFrames;
    const float waveLevelDelta = (mWaveLevel[voiceNum] - mWaveLevelZ[voiceNum]) * invFrames;
    float shapeZ = mShapeZ[voiceNum];
    float waveLevelZ = mWaveLevelZ[voiceNum];
    const float dpwGainCompensation = mDpwGainCompensation[voiceNum];
    for(uint32_t i = 0; i < frames; i++)
    {
      // generate naive saw
      phase = phase + inc;
      float saw = q31_to_f32(phase);

      // square to get parabolic waveform 
      float parabolic = saw * saw;

      // differentiate to get saw
      float dpwSaw = parabolic - sawZ;
      sawZ = parabolic;

      shapeZ += shapeDelta;
      float output = (1.f - shapeZ) * (parabolic * 2.f - 1.f) + shapeZ * (dpwSaw * dpwGainCompensation);
      waveLevelZ += waveLevelDelta;
      write_to_interlaced_buffer(mOscBuffer, output * waveLevelZ, i, 0, 1);
    }
    mPhase[voiceNum] = phase;
    mSawZ[voiceNum] = sawZ;
    mShapeZ[voiceNum] = mShape[voiceNum];
    mWaveLevelZ[voiceNum] = mWaveLevel[voiceNum];
  }

  void GenerateWaveX2(const uint32_t voiceNum, const uint32_t frames)
  {
    int32x2_t phase = s32x2_ld(&mPhase[voiceNum]);
    int32x2_t inc = s32x2_ld(&mPhaseInc[voiceNum]);
    float32x2_t sawZ = f32x2_ld(&mSawZ[voiceNum]);

    const float invFrames = 1.f / float(frames);
    float32x2_t shapeZ = f32x2_ld(&mShapeZ[voiceNum]);
    float32x2_t waveLevelZ = f32x2_ld(&mWaveLevelZ[voiceNum]);
    const float32x2_t shapeDelta = float32x2_mulscal(float32x2_sub(f32x2_ld(&mShape[voiceNum]), shapeZ), invFrames);
    const float32x2_t waveLevelDelta = float32x2_mulscal(float32x2_sub(f32x2_ld(&mWaveLevel[voiceNum]), waveLevelZ), invFrames);
    const float32x2_t dpwGainCompensation = f32x2_ld(&mDpwGainCompensation[voiceNum]);
    for(uint32_t i = 0; i < frames; i++)
    {
      // generate naive saw
      phase = int32x2_add(phase, inc);
      float32x2_t saw = si_i32x2qn_to_f32x2(phase, 31);

      // square to get parabolic waveform 
      float32x2_t parabolic = float32x2_mul(saw, saw);

      // differentiate to get saw
      float32x2_t dpwSaw = float32x2_sub(parabolic, sawZ);
      sawZ = parabolic;

      shapeZ = float32x2_add(shapeZ, shapeDelta);
      float32x2_t output = float32x2_mul(dpwSaw, dpwGainCompensation);
      output = float32x2_mul(shapeZ, output);
      output = float32x2_fmuladd(output, float32x2_sub(f32x2_dup(1.f), shapeZ), float32x2_fmulscaladd(f32x2_dup(-1.f), parabolic, 2.f));

      waveLevelZ = float32x2_add(waveLevelZ, waveLevelDelta);
      write_to_interlaced_bufferf32x2((float *)mOscBuffer, float32x2_mul(output, waveLevelZ), i, 0, 2);
    }
    f32x2_str(&mSawZ[voiceNum], sawZ);
    s32x2_str(&mPhase[voiceNum], phase);
    buf_cpy_f32(&mShape[voiceNum], &mShapeZ[voiceNum], 2);
    buf_cpy_f32(&mWaveLevel[voiceNum], &mWaveLevelZ[voiceNum], 2);
  }

  void GenerateWaveX4(const uint32_t voiceNum, const uint32_t frames)
  {
    int32x4_t phase = s32x4_ld(&mPhase[voiceNum]);
    int32x4_t inc = s32x4_ld(&mPhaseInc[voiceNum]);
    float32x4_t sawZ = f32x4_ld(&mSawZ[voiceNum]);

    const float invFrames = 1.f / float(frames);
    float32x4_t shapeZ = f32x4_ld(&mShapeZ[voiceNum]);
    float32x4_t waveLevelZ = f32x4_ld(&mWaveLevelZ[voiceNum]);
    const float32x4_t shapeDelta = float32x4_mulscal(float32x4_sub(f32x4_ld(&mShape[voiceNum]), shapeZ), invFrames);
    const float32x4_t waveLevelDelta = float32x4_mulscal(float32x4_sub(f32x4_ld(&mWaveLevel[voiceNum]), waveLevelZ), invFrames);
    const float32x4_t dpwGainCompensation = f32x4_ld(&mDpwGainCompensation[voiceNum]);
    for(uint32_t i = 0; i < frames; i++)
    {
      // generate naive saw
      phase = int32x4_add(phase, inc);
      float32x4_t saw = si_i32x4qn_to_f32x4(phase, 31);

      // square to get parabolic waveform 
      float32x4_t parabolic = float32x4_mul(saw, saw);

      // differentiate to get saw
      float32x4_t dpwSaw = float32x4_sub(parabolic, sawZ);
      sawZ = parabolic;

      // scale to -1 ~ 1 for mix
      parabolic = float32x4_fmulscaladd(f32x4_dup(-1.f), parabolic, 2.f);

      shapeZ = float32x4_add(shapeZ, shapeDelta);
      float32x4_t output = float32x4_mul(dpwSaw, dpwGainCompensation);
      output = float32x4_mul(shapeZ, output);
      float32x4_t inverseShape = float32x4_sub(f32x4_dup(1.f), shapeZ);
      output = float32x4_fmuladd(output, inverseShape, parabolic);

      waveLevelZ = float32x4_add(waveLevelZ, waveLevelDelta);
      write_to_interlaced_bufferf32x4(mOscBuffer, float32x4_mul(output, waveLevelZ), i, 0, 4);
    }
    f32x4_str(&mSawZ[voiceNum], sawZ);
    s32x4_str(&mPhase[voiceNum], phase);
    buf_cpy_f32(&mShape[voiceNum], &mShapeZ[voiceNum], 4);
    buf_cpy_f32(&mWaveLevel[voiceNum], &mWaveLevelZ[voiceNum], 4);
  }

  // https://www.musicdsp.org/en/latest/Synthesis/216-fast-whitenoise-generator.html
  void GenerateNoiseX1(const uint32_t voiceNum, const uint32_t frames)
  {
    const float invFrames = 1.f / float(frames);
    const float noiseLevelDelta = (mNoiseLevel[voiceNum] - mNoiseLevelZ[voiceNum]) * invFrames;
    float noiseLevelZ = mNoiseLevelZ[voiceNum];
    for(uint32_t i = 0; i < frames; i++)
    {
      mNoiseX1[voiceNum] ^= mNoiseX2[voiceNum];
      mNoiseX2[voiceNum] += mNoiseX1[voiceNum];
      noiseLevelZ += noiseLevelDelta;
      const float noise = q31_to_f32(mNoiseX2[voiceNum]) * noiseLevelZ;
      const float osc = get_interlaced_sample(mOscBuffer, i, 0, 1);
      write_to_interlaced_buffer(mOscBuffer, osc + noise, i, 0, 1);
    }
    mNoiseLevelZ[voiceNum] = mNoiseLevel[voiceNum];
  }

  void GenerateNoiseX2(const uint32_t voiceNum, const uint32_t frames)
  {
    const float invFrames = 1.f / float(frames);
    float32x2_t noiseLevelZ = f32x2_ld(&mNoiseLevelZ[voiceNum]);
    const float32x2_t noiseLevelDelta = float32x2_mulscal(float32x2_sub(f32x2_ld(&mNoiseLevel[voiceNum]), noiseLevelZ), invFrames);
    int32x2_t noiseX1 = s32x2_ld(&mNoiseX1[voiceNum]);
    int32x2_t noiseX2 = s32x2_ld(&mNoiseX2[voiceNum]);
    for(uint32_t i = 0; i < frames; i++)
    {
      noiseX1 = veor_s32(noiseX1, noiseX2);
      noiseX2 = int32x2_add(noiseX2, noiseX1);

      noiseLevelZ = float32x2_add(noiseLevelZ, noiseLevelDelta);
      const float32x2_t noise = float32x2_mul(si_i32x2qn_to_f32x2(noiseX2, 31), noiseLevelZ);
      const float32x2_t osc = get_interlaced_samplef32x2(mOscBuffer, i, 0, 2);
      write_to_interlaced_bufferf32x2(mOscBuffer, float32x2_add(osc, noise), i, 0, 2);
    }
    buf_cpy_f32(&mNoiseLevel[voiceNum], &mNoiseLevelZ[voiceNum], 2);
    s32x2_str(&mNoiseX1[voiceNum], noiseX1);
    s32x2_str(&mNoiseX2[voiceNum], noiseX2);
  }

  void GenerateNoiseX4(const uint32_t voiceNum, const uint32_t frames)
  {
    const float invFrames = 1.f / float(frames);
    float32x4_t noiseLevelZ = f32x4_ld(&mNoiseLevelZ[voiceNum]);
    const float32x4_t noiseLevelDelta = float32x4_mulscal(float32x4_sub(f32x4_ld(&mNoiseLevel[voiceNum]), noiseLevelZ), invFrames);
    int32x4_t noiseX1 = s32x4_ld(&mNoiseX1[voiceNum]);
    int32x4_t noiseX2 = s32x4_ld(&mNoiseX2[voiceNum]);
    for(uint32_t i = 0; i < frames; i++)
    {
      noiseX1 = veorq_s32(noiseX1, noiseX2);
      noiseX2 = int32x4_add(noiseX2, noiseX1);

      noiseLevelZ = float32x4_add(noiseLevelZ, noiseLevelDelta);
      const float32x4_t noise = float32x4_mul(si_i32x4qn_to_f32x4(noiseX2, 31), noiseLevelZ);
      const float32x4_t osc = get_interlaced_samplef32x4(mOscBuffer, i, 0, 4);
      write_to_interlaced_bufferf32x4(mOscBuffer, float32x4_add(osc, noise), i, 0, 4);
    }
    buf_cpy_f32(&mNoiseLevel[voiceNum], &mNoiseLevelZ[voiceNum], 4);
    s32x4_str(&mNoiseX1[voiceNum], noiseX1);
    s32x4_str(&mNoiseX2[voiceNum], noiseX2);
  }
  /*===========================================================================*/
  /* Constants. */
  /*===========================================================================*/
};
