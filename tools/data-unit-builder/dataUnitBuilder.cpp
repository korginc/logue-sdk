#include <string>
#include <dirent.h>
#include <cstdio>

const uint32_t maxDataSize = 48000;
const std::string headerPath = "output/DataUnit.h";
const std::string sourcePath = "output/DataUnit.cpp";

void AddHeaderEntry(struct dirent * entry, int size, std::string fileName, FILE * header)
{
    const std::string dataType = "    extern const char * ";
    const std::string sizeType = "    const int           ";
    const std::string semicolon = ";\n";
    const std::string newline = "\n";
    const std::string sizeString = std::to_string(size);
    
    fwrite(dataType.c_str(), sizeof(char), dataType.length(), header);
    fwrite(fileName.c_str(), sizeof(char), fileName.length(), header);
    fwrite(semicolon.c_str(), sizeof(char), semicolon.length(), header);

    fwrite(sizeType.c_str(), sizeof(char), sizeType.length(), header);
    fwrite(sizeString.c_str(), sizeof(char), sizeString.length(), header);
    fwrite(semicolon.c_str(), sizeof(char), semicolon.length(), header);
    fwrite(newline.c_str(), sizeof(char), newline.length(), header);
}

void AddSourceEntry(std::string fileName, FILE * dataFile, FILE * output)
{
    const std::string tempName = "temp_" + fileName;
    const std::string dataType = "\nstatic const unsigned char temp_" + fileName;
    const std::string brackets = "[] =\n{\n";
    const std::string closeBrace = "\n};\n";
    const std::string comma = ", ";
    const std::string linebreak = "\n";
    const std::string assign = "\nconst char * " + fileName + " = (const char *) " + tempName + ";\n";

    fwrite(dataType.c_str(), sizeof(char), dataType.length(), output);
    fwrite(brackets.c_str(), sizeof(char), brackets.length(), output);

    int lineBreakCount = 0;
    const int lineBreakLimit = 32;
    while(!feof(dataFile))
    {
        int8_t data;
        fread(&data, sizeof(int8_t), 1, dataFile);
        std::string a = std::to_string(static_cast<int>(data));

        fwrite(a.c_str(), sizeof(char), a.length(), output);

        fwrite(comma.c_str(), sizeof(char), comma.length(), output);
        lineBreakCount++;
        if(lineBreakCount == lineBreakLimit)
        {
            lineBreakCount = 0;
            fwrite(linebreak.c_str(), sizeof(char), linebreak.length(), output);
        }
    }

    fwrite(closeBrace.c_str(), sizeof(char), closeBrace.length(), output);
    fwrite(assign.c_str(), sizeof(char), assign.length(), output);
}

bool BuildDataUnit(std::string folder,FILE * header, FILE * source)
{
    uint32_t len = folder.length();
    DIR * directory = opendir(folder.c_str());
    struct dirent * entry = nullptr;
    struct dirent * prevEntry = nullptr;
    uint32_t currentDataUsage = 0;
    while ((entry = readdir(directory)) != NULL)
    {
        if(entry->d_type == DT_REG)
        {
            printf("%s\n", entry->d_name);

            std::string filePath = folder + "/" + entry->d_name;

            FILE * file;
            file = fopen(filePath.c_str(), "rb");

            if(file == nullptr)
            {   
                printf("file couldn't be opened %s\n", filePath.c_str());
                continue;
            }

            fseek(file, 0, SEEK_END);
            int size = ftell(file);
            fseek(file, 0, SEEK_SET);

            currentDataUsage += size;
            if(currentDataUsage >= maxDataSize)
            {
                printf("Too much data!\n");
                if(prevEntry != nullptr)
                {
                    printf("The final file sucecssfully written was %s.\n", prevEntry->d_name);
                }
                else
                {
                    printf("Was unable to write any files.\n");
                }
                printf("Please reduce data to %d bytes or less\n", maxDataSize);
                break;
            }

            std::string fileName(entry->d_name);
            size_t lastindex = fileName.find_last_of("."); 
            fileName = fileName.substr(0, lastindex);         

            AddHeaderEntry(entry, size, fileName, header);
            AddSourceEntry(fileName, file, source);
            prevEntry = entry;
        }
    }

    return true;
}

// argument 1 data directory
// argument 2 output file name 
int main(int argc, char *argv[])
{
    auto name = argv[2];
    FILE * header = fopen(headerPath.c_str(), "w");
    FILE * source = fopen(sourcePath.c_str(), "w");

    if(header == nullptr || source == nullptr)
    {
        printf("Could not open output files\n");
        return -1;
    }

    std::string autoGeneratedWarning = "/*---------------------------------------------------\n\nThis code is auto generated. Do not edit\n\n---------------------------------------------------*/\n\n";
    std::string headerBoilerPlate = "#pragma once\n\nnamespace DataUnit\n{\n";
    fwrite(autoGeneratedWarning.c_str(), sizeof(char), autoGeneratedWarning.length(), header);
    fwrite(headerBoilerPlate.c_str(), sizeof(char), headerBoilerPlate.length(), header);

    std::string sourceBoilerPlate = "#include \"dataUnit.h\"\n\nnamespace DataUnit\n{\n";
    fwrite(autoGeneratedWarning.c_str(), sizeof(char), autoGeneratedWarning.length(), source);
    fwrite(sourceBoilerPlate.c_str(), sizeof(char), sourceBoilerPlate.length(), source);

    BuildDataUnit(argv[1], header, source);

    char closeBrace = '}';
    fwrite(&closeBrace, sizeof(char), sizeof(closeBrace), header);
    fwrite(&closeBrace, sizeof(char), sizeof(closeBrace), source);

    fclose(header);
    fclose(source);
    return 0;
}